/*
 * CAMERA_REGULATOR.H
 *
 *  Created on: 4 mar 2015
 *      Author: szymon
 */

#ifndef CAMERA_REGULATOR_H_
#define CAMERA_REGULATOR_H_

#include <opencv/cv.h>
#include <opencv/cv.h>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/calib3d/calib3d.hpp>
#include <opencv2/video.hpp>
#include <opencv2/stitching.hpp>
#include <iostream>
#include "DEF.H"




class CAMERA_REGULATOR
{

private:

	cv::VideoCapture  cap;
	cv::Mat foundedCorners;
	cv::Mat lastFrame;
	CvSize csSize;


	int centerX;
	int centerY;
	cv::Scalar a;


	CAMERA_REGULATOR(CAMERA_REGULATOR& cam)
	{
		//todo
	}

	//METHODS

	void receiveFrame()
	{
		cap >> lastFrame;

		centerX=lastFrame.cols/2;
		centerY=lastFrame.rows/2;
	}

	cv::Mat& getLastFrame()
	{

		receiveFrame();
		cv::cvtColor(lastFrame,lastFrame,CV_BGR2GRAY);
		return lastFrame;


	}

	bool findChessboard()
		{
			getLastFrame();
			bool founded=cv::findChessboardCorners(lastFrame,csSize,foundedCorners,1);
			return founded;
		}


	void checkHorizontal()
				{
					float dif1=foundedCorners.ptr<cv::Vec2f>(1)->val[0]-foundedCorners.ptr<cv::Vec2f>(0)->val[0];
									float dif2=	foundedCorners.ptr<cv::Vec2f>(foundedCorners.rows*foundedCorners.cols-1)->val[0]-foundedCorners.ptr<cv::Vec2f>(foundedCorners.rows*foundedCorners.cols-2)->val[0];
									if((dif1)>(dif2))
													{
														//std::cout << "Prawa Bliżej";
														cv::circle(lastFrame,cv::Point((centerX-(dif1-dif2)*6),centerY),50,a,20);
													}
													else
														{
														//std::cout << "Lewa Bliżej";

														cv::circle(lastFrame,cv::Point((centerX+(dif2-dif1)*6),centerY),50,a,20);
														}
				}

	void checkVertical()
	{
		float dif1=foundedCorners.ptr<cv::Vec2f>(1)->val[1]-foundedCorners.ptr<cv::Vec2f>(0)->val[1];
		float dif2=	foundedCorners.ptr<cv::Vec2f>(foundedCorners.rows*foundedCorners.cols-1)->val[1]-foundedCorners.ptr<cv::Vec2f>(foundedCorners.rows*foundedCorners.cols-2)->val[1];
		if((dif1)>(dif2))
								{
																//std::cout << "Prawa Bliżej";
																cv::circle(lastFrame,cv::Point(centerX,(centerY-(dif1-dif2)*6)),50,a,20);
															}
															else
																{
																//std::cout << "Lewa Bliżej";

																cv::circle(lastFrame,cv::Point(centerX,(centerY+(dif2-dif1)*6)),50,a,20);
																}
	}
public:

	CAMERA_REGULATOR(int camera=0,CvSize size=CvSize(8,5),cv::Scalar color=cv::Scalar(200)): csSize(size), a(color)
	{
		cap.open(camera);


	}

	~CAMERA_REGULATOR()
	{
		cap.release();
	}

	//METHODS



	void run()
	{
		while(true)
		{
		if(findChessboard())
			{
				//findChessboard();


				cv::circle(lastFrame,cv::Point(centerX,centerY),90,a,20);

				checkHorizontal();
				checkVertical();


				cv::drawChessboardCorners(lastFrame, csSize, foundedCorners, 1);;


			}
			cv::imshow("N",lastFrame);

			if(cv::waitKey(1)=='c')
			{

				break;


			}

		}
	}


	void stop()
	{

	}


};





#endif /* CAMERA_REGULATOR_H_ */
